const axios = require("axios");
const { EmbedBuilder, ActionRowBuilder, StringSelectMenuBuilder } = require("discord.js");
const akhfhid = process.env.BASE_API;

module.exports = {
    name: "text2speech",
    alias: ["tts"],
    description: "Convert text to speech using OpenAI TTS",
    run: async (client, message, args) => {
        const text = args.join(" ");

        if (!text) {
            return message.reply("Please provide text to convert to speech. Usage: `!tts <text>`");
        }

        const voices = [
            { label: "Alloy", value: "alloy", description: "Versatile and balanced voice" },
            { label: "Echo", value: "echo", description: "Warm and rounded voice" },
            { label: "Fable", value: "fable", description: "British accent, versatile voice" },
            { label: "Onyx", value: "onyx", description: "Deep and resonant voice" },
            { label: "Nova", value: "nova", description: "Energetic and bright voice" },
            { label: "Shimmer", value: "shimmer", description: "Clear and expressive voice" }
        ];

        const selectMenu = new StringSelectMenuBuilder()
            .setCustomId("tts_voice_select")
            .setPlaceholder("Choose a voice...")
            .addOptions(
                voices.map(v => ({
                    label: v.label,
                    value: v.value,
                    description: v.description
                }))
            );

        const row = new ActionRowBuilder().addComponents(selectMenu);

        const embed = new EmbedBuilder()
            .setColor("#0099FF")
            .setTitle("Text to Speech")
            .setDescription(`**Text:** ${text}\n\nPlease select a voice from the menu below to generate speech.`)
            .setFooter({ text: `Requested by ${message.author.tag}` });

        const replyMsg = await message.reply({
            embeds: [embed],
            components: [row]
        });

        const filter = (i) => i.customId === "tts_voice_select" && i.user.id === message.author.id;
        const collector = replyMsg.createMessageComponentCollector({ filter, time: 60000 });

        collector.on("collect", async (interaction) => {
            const voice = interaction.values[0];

            let seconds = 0;
            const loadingEmbed = new EmbedBuilder()
                .setColor("#FFFF00")
                .setTitle("ðŸ—£ï¸ Text to Speech")
                .setDescription(
                    `Generating speech with **${voice}** voice...\n\n**Text:** ${text}`
                )
                .addFields(
                    { name: "â±ï¸ Duration", value: "0 Sec", inline: true },
                    { name: "ðŸ“Š Status", value: "Processing text...", inline: true }
                )
                .setTimestamp()
                .setFooter({
                    text: `Generated by ${client.user.username} | requested by ${message.author.tag}`,
                });

            await interaction.update({
                content: null,
                components: [],
                embeds: [loadingEmbed],
            });

            const timer = setInterval(() => {
                seconds++;
                const updated = EmbedBuilder.from(loadingEmbed)
                    .setFields(
                        { name: "â±ï¸ Duration", value: `${seconds} Sec`, inline: true },
                        { name: "ðŸ“Š Status", value: "Synthesizing audio...", inline: true }
                    )
                    .setTimestamp()
                    .setFooter({
                        text: `Generated by ${client.user.username} | requested by ${message.author.tag}`,
                    });
                interaction.editReply({ embeds: [updated] }).catch(() => { });
            }, 1000);

            try {
                const apiUrl = `${akhfhid}/tools/tts/openai`;
                const response = await axios.get(apiUrl, {
                    params: {
                        text: text,
                        voice: voice
                    }
                });

                clearInterval(timer);

                if (response.data && response.data.success && response.data.result) {
                    const audioUrl = response.data.result;
                    const timeTaken = response.data.responseTime || "N/A";

                    const safeFilename = text.replace(/[^a-zA-Z0-9]/g, "_").slice(0, 20) || "speech";
                    const attachment = { attachment: audioUrl, name: `${safeFilename}.mp3` };

                    const resultEmbed = new EmbedBuilder()
                        .setColor("#00FF00")
                        .setTitle(`âœ¨ TTS Result`)
                        .setDescription(
                            `**Text:** ${text}\n**Voice:** ${voice}\n**Time:** ${timeTaken}`
                        )
                        .setFooter({ text: `Generated by ${client.user.username} | requested by ${message.author.tag}` })
                        .setTimestamp();

                    await interaction.editReply({
                        embeds: [resultEmbed],
                        files: [attachment]
                    });
                } else {
                    throw new Error("API returned unsuccessful response");
                }
            } catch (error) {
                clearInterval(timer);
                console.error("TTS Error:", error);
                await interaction.editReply({
                    content: " Failed to generate speech. The API might be down.",
                    embeds: []
                });
            }
            collector.stop();
        });

        collector.on("end", (collected, reason) => {
            if (reason === "time") {
                replyMsg.edit({
                    content: " Interaction timed out.",
                    components: [],
                    embeds: []
                }).catch(() => { });
            }
        });
    }
};
